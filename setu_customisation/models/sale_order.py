import random
import string
import threading
from odoo import fields, models, api, _
from odoo.exceptions import UserError
import odoo
from datetime import timedelta
from dateutil.relativedelta import relativedelta


class SaleOrder(models.Model):
    _inherit = "sale.order"

    rm_number_id = fields.Many2one(
        "rm.numbers", string="Rm Numbers")
    incorporation_date = fields.Date(string="Incorporation Date", tracking=True)
    has_seed_fund = fields.Boolean(compute="_compute_has_seed_fund", store=True)
    customer_source_id = fields.Many2one("customer.source", string="Customer Source")
    customer_email = fields.Char(related="partner_id.email", string="Customer Email")
    customer_phone = fields.Char(related="partner_id.mobile", string="Customer Phone")
    pi_generated_by = fields.Many2one("res.users", string="PI Generated By")
    pi_generated_on = fields.Datetime(string="PI Generated On")
    closer_id = fields.Many2one('hr.employee', string="Emp Closer", tracking=True)
    closer_user_id = fields.Many2one('res.users', string="Closer", tracking=True)
    
    agreement_active_date = fields.Date(string="Agreement Active Date", tracking=True)
    funding_month_id = fields.Many2one('funding.service.month', string="Funding Month", tracking=True)
    expired_date = fields.Date(string="Expired Date", store=True, compute="_compute_expired_date", tracking=True)
    agreement_status_id = fields.Many2one('agreement.status', string="Agreement Status", tracking=True)
    agreement_close_date = fields.Date(string="Agreement Close Date", tracking=True)
    is_refund = fields.Boolean(string='Refund')
    
    @api.model
    def update_closer_user_ids(self):
        """Scheduler to update closer_user_id from closer_id for all sale orders."""
        orders = self.search([('closer_id', '!=', False)])
        for order in orders:
            if order.closer_id and order.closer_id.user_id:
                order.closer_user_id = order.closer_id.user_id
            else:
                order.closer_user_id = False

    @api.depends('agreement_active_date', 'funding_month_id')
    def _compute_expired_date(self):
        for rec in self:
            if rec.funding_month_id and rec.funding_month_id.month_number and rec.agreement_active_date:
                rec.expired_date = rec.agreement_active_date + relativedelta(months=rec.funding_month_id.month_number)
            else:
                rec.expired_date = False

    # def print_sale_order(self):
        # for order in self:
        #     order.pi_generated_by = self.env.user
        #     order.pi_generated_on = datetime.now()
        # return super(SaleOrder, self).print_sale_order()

    @api.model
    def create(self, vals):
        order = super(SaleOrder, self).create(vals)
        if 'incorporation_date' in vals:
            tasks = self.env['project.task'].search([
                ('sale_order_id', '=', order.id)
            ])
            for task in tasks:
                task.incorporation_date = vals['incorporation_date']
        return order

    def write(self, vals):
        res = super(SaleOrder, self).write(vals)
        if 'incorporation_date' in vals:
            for order in self:
                # You need to adjust this line depending on how tasks are linked
                tasks = self.env['project.task'].search([
                    ('sale_order_id', '=', order.id)
                ])
                for task in tasks:
                    task.incorporation_date = vals['incorporation_date']
        return res

    @api.model
    def update_task_incorporation_dates(self):
        orders = self.search([
            ('incorporation_date', '!=', False),
            ('tasks_ids', '!=', False)
        ])

        for order in orders:
            for task in order.tasks_ids:
                if task.incorporation_date != order.incorporation_date:
                    task.incorporation_date = order.incorporation_date

    @api.onchange('order_line')
    def _compute_has_seed_fund(self):
        """Check if 'Seed Fund' is in the order lines."""
        for order in self:
            for line in order.order_line:
                if line.product_template_id.name == "SEED FUND":
                    order.has_seed_fund = True
                else:
                    order.has_seed_fund = False
    
    def generate_password(self):
        """Generate a unique password and log in chatter. Show 'Re-generate Password' button only after first generation."""
        if not self.app_email:
            raise UserError(_("Application Email is required. Please add an email before proceeding."))

        password_length = 12
        characters = string.ascii_letters + string.digits + string.punctuation

        new_password = self.app_password
        while new_password == self.app_password:
            new_password = ''.join(random.choices(characters, k=password_length))

        # Define message for chatter
        message = _(
            f"ðŸ” **Password {'Generated' if not self.is_password_generated else 'Re-Generated'} by:** {self.env.user.name}\n\n"
            f"**1. Customer Email:** {self.app_email}\n\n"
            f"**2. Generated Password:** {new_password}"
        )

        # Update password field & flag
        self.write({'app_password': new_password, 'is_password_generated': True})

        # Log in chatter
        self.message_post(body=message)

    # @api.model
    # def get_paginated_orders(self, last_id=0, page_size=40):
    #     """Fetch sale orders using indexed pagination for better performance."""
    #     print("\n\n\nDoneeeeeeeeeeee")
    #     domain = [('id', '>', last_id)] if last_id else []
    #     orders = self.env['sale.order'].search(domain, order='id asc', limit=page_size)
    #     return orders

    # @api.model
    # def get_orders_fast(self, last_id=0, page_size=40):
    #     """Fetch sale orders using raw SQL for optimized pagination."""
    #     print("\n\n\nCallllllllllllll")
    #     query = """
    #         SELECT id, name, partner_id, amount_total, state 
    #         FROM sale_order 
    #         WHERE id > %s 
    #         ORDER BY id ASC 
    #         LIMIT %s
    #     """
    #     self.env.cr.execute(query, (last_id, page_size))
    #     records = self.env.cr.fetchall()
    #     _logger.info(f"Fetched {len(records)} orders from DB.")
    #     return records

    # @api.depends('user_id')
    # def _compute_operating_company_domain(self):
    #     """Compute domain for operating_company_id based on user branch."""
    #     for order in self:
    #         branch = self.env['employee.branch'].search([('name', '=', order.user_id.employee_id.branch_id.name)], limit=1)
    #         if branch:
    #             order.operating_company_domain = branch.company_ids.ids
    #         else:
    #             order.operating_company_domain = []

    # operating_company_id = fields.Many2one(
    #     "operating.company",
    #     string="Operating Company",
    #     copy=False,
    #     domain="[('id', 'in', operating_company_domain)]"
    # )

    # operating_company_domain = fields.Many2many(
    #     'operating.company',
    #     compute="_compute_operating_company_domain",
    #     store=False
    # )