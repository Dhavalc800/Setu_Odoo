from odoo import api, fields, models, _
from odoo.exceptions import ValidationError,UserError
import requests
import re
import logging

_logger = logging.getLogger(__name__)

class SaleOrder(models.Model):
    _inherit = "sale.order"
    
    # def _get_default_bank_acc(self):
    #     return self.env["res.partner.bank"].search([], limit=1).id
    
    date = fields.Date(string="Date")
    other_ref = fields.Char(string="Other Reference")
    bank_acc_id = fields.Many2one("res.partner.bank", "Bank Account")
    # bank_acc_id = fields.Many2one(
    #     related='operating_company_id.bank_account_id',
    #     string="Bank Account",
    #     readonly=False,  # Set to True if you want it read-only
    #     store=True  # Optional: adds this field to database, useful for filtering/search
    # )

    def action_operating_comp(self):
        """Your custom method to be called when printing"""
        employee_branch = self.user_id.employee_id.branch_id
        branch = self.env['employee.branch'].search([('id', '=', employee_branch.id)])
        self.operating_company_id = branch.company_ids.id
        self.pi_generated_by = self.env.user
        self.pi_generated_on = fields.Datetime.now()

    payment_plan_id = fields.Many2one("payment.plan", required=True, copy=False)

    payment_plan_line_ids = fields.One2many("sale.payment.line", "sale_id")
    state_history_ids = fields.One2many(
        "state.history", "order_id", string="State history"
    )
    link_generated_by = fields.Many2one('res.users','Link Generated By')
    link_generated_on = fields.Datetime('Link Generated On')
    payment_link = fields.Char(string='Payment Link')

    lock_date = fields.Date(
        string='Lock Date'
    )
    locked_by = fields.Many2one('res.users', 'Locked By')

    @api.onchange("operating_company_id")
    def _onchange_operating_company_id(self):
        self.bank_acc_id = (
            self.operating_company_id.partner_id.bank_ids
            and self.operating_company_id.partner_id.bank_ids[0].id
        )

    def action_done(self):
        res = super().action_done()
        self.write({'lock_date': fields.Date.today(), 'locked_by': self.env.user})
        return res

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super().fields_get()
        if self.env.user.has_group("sales_team.group_sale_manager"):
            res["user_id"]["readonly"] = False
            res["team_id"]["readonly"] = False
        else:
            res["user_id"]["readonly"] = True
            res["team_id"]["readonly"] = True
        return res

    @api.constrains("payment_plan_line_ids")
    def _check_line_ids(self):
        if sum(self.payment_plan_line_ids.mapped("percentage")) > 100:
            raise ValidationError(
                _("Ensure that the cumulative percentage does not exceed 100%.")
            )

    @api.onchange("payment_plan_id")
    def _onchange_payment_plan_id(self):
        self.payment_plan_line_ids = [(6, 0, [])]
        if self.payment_plan_id:
            self.payment_plan_line_ids = [
                (
                    0,
                    0,
                    {
                        "state": plan.state,
                        "percentage": plan.percentage,
                        "is_advance": plan.is_advance,
                    },
                )
                for plan in self.payment_plan_id.line_ids
            ]

    state = fields.Selection(
        selection=[
            ("draft", "Booking"),
            ("sent", "Booking Sent"),
            ("sale", "Sales Order"),
            ("done", "Locked"),
            ("cancel", "Cancelled"),
        ],
        string="Status",
        readonly=True,
        copy=False,
        index=True,
        tracking=3,
        default="draft",
    )

    @api.depends("state")
    def _compute_type_name(self):
        for record in self:
            if record.state in ("draft", "sent", "cancel"):
                record.type_name = _("Booking")
            else:
                record.type_name = _("Sales Order")

    def write(self, vals):
        state_history_obj = self.env["state.history"]
        res = super().write(vals)
        if "state" in vals:
            state = dict(self._fields["state"].selection).get(self.state)
            previous_state_history = state_history_obj.search(
                [
                    ("order_id", "=", self.id),
                    ("current_state", "=", True),
                    ("substate_id", "=", False),
                ],
                order="id desc",
                limit=1,
            )
            previous_state_history.compute_duration()
            previous_state_history.current_state = False
            state_history_obj.create(
                {
                    "state": state,
                    "user": self.env.user.id,
                    "order_id": self.id,
                    "current_state": True,
                }
            )

            if 'cancel' in vals['state']:
                if self.agreement_id:
                    if self.agreement_id.sale_id:
                        # Archived Agreement in when order set to draft state
                        self.agreement_id.active = False
                        self.agreement_id = False
                if self.tasks_ids:
                    # Archived Tasks in when order set to draft state
                    self.tasks_ids.active = False

        if "substate_id" in vals:
            substate_id = self.env["base.substate"].browse(vals["substate_id"])
            if (
                substate_id
                and substate_id.sudo().groups_ids
                and self.env.user not in substate_id.sudo().groups_ids.users
            ):
                raise ValidationError("You are not allowed to set this substate")
            previous_substate_history = state_history_obj.search(
                [
                    ("order_id", "=", self.id),
                    ("current_state", "=", True),
                    ("substate_id", "!=", False),
                ],
                order="id desc",
                limit=1,
            )
            previous_substate_history.compute_duration()
            previous_substate_history.current_state = False
            state_history_obj.create(
                {
                    "substate_id": self.substate_id.id,
                    "state": self.substate_id.name,
                    "user": self.env.user.id,
                    "order_id": self.id,
                    "current_state": True,
                }
            )
        return res

    def action_view_invoice(self):
        action = super().action_view_invoice()

        if not self.user_has_groups("account.group_account_invoice"):
            ctx = action.get("context")
            ctx.update({"create": False, "edit": False})
            action["context"] = ctx
        return action

    def validate_pan(self, pan):
        # PAN format: 5 uppercase letters, 4 digits, 1 uppercase letter
        pattern = r"^[A-Z]{5}[0-9]{4}[A-Z]$"

        if re.match(pattern, pan):
            return True
        else:
            return False

    # @api.constrains("partner_id", "partner_invoice_id")
    def _check_fields_customer(self):
        for rec in self:
            errors = []

            # Check Customer PAN
            if not rec.partner_id.l10n_in_pan:
                errors.append(_("Missing PAN number in Customer"))
            elif not self.validate_pan(rec.partner_id.l10n_in_pan):
                errors.append(_("Invalid PAN format in Customer"))

            # Check Customer Mobile and Email
            if not rec.partner_id.mobile:
                errors.append(_("Mobile number missing in Customer"))
            if not rec.partner_id.email:
                errors.append(_("Email address missing in Customer"))

            # Only check partner_invoice_id if it's different from partner_id
            if rec.partner_id != rec.partner_invoice_id:
                # Check Invoice Address PAN
                if not rec.partner_invoice_id.l10n_in_pan:
                    errors.append(_("Missing PAN number in Invoice Address"))
                elif not self.validate_pan(rec.partner_invoice_id.l10n_in_pan):
                    errors.append(_("Invalid PAN format in Invoice Address"))

                # Check Invoice Address Mobile and Email
                if not rec.partner_invoice_id.mobile:
                    errors.append(_("Mobile number missing in Invoice Address"))
                if not rec.partner_invoice_id.email:
                    errors.append(_("Email address missing in Invoice Address"))

            # Raise validation error if any errors were found
            if errors:
                raise ValidationError("\n".join(errors))

    @api.model_create_multi
    def create(self, vals_list):
        records = super().create(vals_list)
        records._check_fields_customer()
        return records


class SaleOrderLine(models.Model):
    _inherit = "sale.order.line"

    distribution_amount = fields.Float()
    tax_received = fields.Monetary(string="Tax Received", copy=False, default=0.0)

    def write(self, vals):
        for line in self:
            old_product = line.product_id
            result = super(SaleOrderLine, self).write(vals)

            if 'product_id' in vals:
                new_product = self.env['product.product'].browse(vals['product_id'])
                order = line.order_id
                partner = order.partner_id

                # üõë Skip if old or new product is "Down Payment"
                if 'down payment' in (old_product.name or '').lower() or 'down payment' in (new_product.name or '').lower():
                    _logger.info("‚è≠Ô∏è Skipping WhatsApp notification for Down Payment product.")
                    continue

                # ‚úâÔ∏è Compose message with emojis
                message = (
                    f"üì¶ *Product Change Alert!*\n"
                    f"üßæ *Order:* {order.name}\n"
                    f"üôç‚Äç‚ôÇÔ∏è *Customer:* {partner.name}\n"
                    f"üîÅ *Old Product:* {old_product.name}\n"
                    f"üÜï *New Product:* {new_product.name}\n"
                    f"üë®‚Äçüíº *Changed By:* {self.env.user.name}"
                )

                # üéØ Collect all recipients
                recipients = set()

                # 1. RM
                if order.rm_number_id:
                    recipients.add(order.rm_number_id.phone)
                    print("\n\n\nReciptiiiiiii",recipients)
                # 2. Admin
                admin = self.env['res.users'].search([
                    ('groups_id', 'in', [self.env.ref('base.group_system').id])], limit=1)
                print("\n\n\nAdminnnnnnnnnn",admin)
                if admin and admin.employee_id.mobile_phone:
                    recipients.add(admin.partner_id.mobile)

                # 3. Salesperson
                if order.user_id:
                    recipients.add(order.user_id.employee_id.mobile_phone)

                # 4. Gamification DATA
                if order.gamification_data_ids:
                    for gemificatin in order.gamification_data_ids:
                        recipients.add(gemificatin.salesperson_id.mobile)
                        print("\n\n\nredddddddddd",gemificatin.salesperson_id)
                
                # üöÄ Send WhatsApp messages
                if recipients:
                    self.send_whatsapp_ultramsg_bulk(list(recipients), message)

            return result

    def send_whatsapp_ultramsg_bulk(self, phones, message):
        instance_id = "instance82316"
        token = "s7hu2idj4dl4nh24"
        base_url = f"https://api.ultramsg.com/{instance_id}/messages/chat"

        for phone in phones:
            payload = {
                "token": token,
                "to": phone,
                "body": message
            }
            try:
                response = requests.post(base_url, json=payload)
                response.raise_for_status()
                _logger.info(f"‚úÖ WhatsApp message sent to {phone}")
            except Exception as e:
                _logger.error(f"‚ùå Failed to send WhatsApp message to {phone}: {str(e)}")


    def get_tax_recieved_amount(self, sale_order, date_from, date_to, total_month_payment=0):
        sum_of_content_amount_before_date = 0  # Sum of payments before date_from
        sum_of_content_amount_during_period = 0  # Sum of payments between date_from and date_to

        # Iterate through each invoice associated with the sale order
        for invoice in sale_order.invoice_ids:
            if invoice.invoice_payments_widget:
                content = invoice.invoice_payments_widget.get("content", [])
                # Iterate through payment content
                for value in content:
                    account_payment_id = self.env['account.payment'].browse(value.get('account_payment_id'))
                    if not account_payment_id.settled and account_payment_id.payment_type == 'inbound' and self._context.get('adjust_settlement'):
                        payment_date = value.get("date")
                        payment_amount = value.get("amount", 0)

                        # Payments before the date_from
                        if payment_date and payment_date < date_from:
                            sum_of_content_amount_before_date += payment_amount

                        # Payments between date_from and date_to
                        elif payment_date and date_from <= payment_date <= date_to:
                            sum_of_content_amount_during_period += payment_amount
                    else:
                        account_payment_id = self.env['account.payment'].browse(value.get('account_payment_id'))
                        if account_payment_id.payment_type == 'inbound':
                            payment_date = value.get("date")
                            payment_amount = value.get("amount", 0)

                            # Payments before the date_from
                            if payment_date and payment_date < date_from:
                                sum_of_content_amount_before_date += payment_amount

                            # Payments between date_from and date_to
                            elif payment_date and date_from <= payment_date <= date_to:
                                sum_of_content_amount_during_period += payment_amount


        # Process tax calculation for both periods
        total_month_payment = sum_of_content_amount_during_period  # During period total

        # Dictionary to store tax calculations
        tax_calculations = {
            "before_date_from": 0.0,
            "during_period": 0.0,
        }

        # Map and calculate tax for the order lines
        for order in self.mapped("order_id"):
            # Calculate the total base amount (excluding tax)
            total_base_amount = sum(
                line.price_subtotal + line.price_tax for line in order.order_line
            )
            if total_base_amount == 0:
                # skip this order
                continue
            # Allocate payments and calculate tax for each line
            for line in order.order_line.filtered(lambda l: not l.display_type and not l.is_downpayment):
                # Calculate the proportion of this line's base amount

                base_amount = (line.price_unit * line.product_uom_qty) + line.price_tax
                proportion = base_amount / total_base_amount

                # Allocate payment for the period before `date_from`
                allocated_payment_before_date = sum_of_content_amount_before_date * proportion
                allocated_payment_during_period = total_month_payment * proportion
                # Calculate tax for the amount before date_from
                product_tax_before_date = 0.0
                if line.tax_id:
                    tax_amount_before_list = [
                        tax.compute_all(
                            allocated_payment_before_date
                            / (1 + sum(tax.amount / 100 for tax in line.tax_id if tax.tax_group_id.name != "TDS")),
                            line.order_id.currency_id,
                            line.product_uom_qty,
                            line.product_id,
                            line.order_id.partner_id,
                        )["taxes"]
                        for tax in line.tax_id if tax.tax_group_id.name != "TDS"
                    ]

                    if tax_amount_before_list:
                        for amount in tax_amount_before_list[0]:
                            product_tax_before_date += amount.get("amount")

                    # tax_amount_before = [
                    #     tax.compute_all(
                    #         allocated_payment_before_date
                    #         / (1 + sum(tax.amount / 100 for tax in line.tax_id if tax.tax_group_id.name != "TDS")),
                    #         line.order_id.currency_id,
                    #         line.product_uom_qty,
                    #         line.product_id,
                    #         line.order_id.partner_id,
                    #         )["taxes"]
                    #     for tax in line.tax_id if tax.tax_group_id.name != "TDS"
                    # ][0]
                    # for amount in tax_amount_before:
                    #     product_tax_before_date += amount.get("amount")

                # Store the tax amount before date_from in the dictionary
                # line.tax_received_dict["before_date_from"] = product_tax_before_date

                # Calculate tax for the amount during the period (date_from to date_to)
                product_tax_during_period = 0.0
                if line.tax_id:
                    non_tds_taxes = [tax for tax in line.tax_id if tax.tax_group_id.name != "TDS"]
                    total_tax_percent = sum(tax.amount / 100 for tax in non_tds_taxes)

                    if non_tds_taxes and total_tax_percent:
                        computed_taxes = non_tds_taxes[0].compute_all(
                            allocated_payment_during_period / (1 + total_tax_percent),
                            line.order_id.currency_id,
                            line.product_uom_qty,
                            line.product_id,
                            line.order_id.partner_id,
                        ).get("taxes", [])

                        for tax_amount in computed_taxes:
                            product_tax_during_period += tax_amount.get("amount", 0.0)

                # product_tax_during_period = 0.0
                # if line.tax_id:
                #     tax_amount_during = [
                #         tax.compute_all(
                #             allocated_payment_during_period
                #             / (1 + sum(tax.amount / 100 for tax in line.tax_id if tax.tax_group_id.name != "TDS")),
                #             line.order_id.currency_id,
                #             line.product_uom_qty,
                #             line.product_id,
                #             line.order_id.partner_id,
                #             )["taxes"]
                #         for tax in line.tax_id if tax.tax_group_id.name != "TDS"
                #     ][0]
                #     for amount in tax_amount_during:
                #         product_tax_during_period += amount.get("amount")
                # Store the tax amount during the period in the dictionary
                # line.tax_received_dict["during_period"] = product_tax_during_period

                # Optionally: Store the tax dictionary globally (for all lines)
                tax_calculations["before_date_from"] += product_tax_before_date
                tax_calculations["during_period"] += product_tax_during_period
            return tax_calculations

    @api.constrains("distribution_amount", "price_subtotal")
    def _check_distribution_amount(self):
        for rec in self:
            if rec.distribution_amount > rec.price_subtotal:
                raise ValidationError(
                    _("Distribution Amount can't be great than Subtotal")
                )

    @api.depends("product_id")
    def _compute_name(self):
        super()._compute_name()
        for line in self:
            line.name = "Consultancy Service"

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if vals.get("display_type") not in ("line_section", "line_note"):
                vals.update({"name": "Consulting Services."})
        return super().create(vals_list)

    # def unlink(self):
    #     res = super().unlink()
    #     for line in self:
    #         print("line-----", line)
    #         if line.task_id:
    #             line.task_id.unlink()
    #         return res

class SalePaymentLine(models.Model):
    _name = "sale.payment.line"
    _description = "Sale Payment Line"

    def _compute_amount(self):
        for rec in self:
            rec.amount = (
                rec.sale_id.amount_tax
                and ((rec.percentage / 100) * rec.sale_id.amount_total)
                or 0.0
            )

    state = fields.Char(string="Stage")
    percentage = fields.Float()
    amount = fields.Float(compute="_compute_amount")
    is_advance = fields.Boolean("Advance Payment")
    sale_id = fields.Many2one("sale.order")

    @api.constrains("percentage", "is_advance")
    def _check_percentage(self):
        for rec in self:
            if not (0 < rec.percentage <= 100):
                raise ValidationError(
                    _("Ensure that the percentage does not exceed 100%.")
                )
            if rec.is_advance and self.search(
                [
                    ("is_advance", "=", True),
                    ("id", "!=", rec.id),
                    ("sale_id", "=", rec.sale_id.id),
                ]
            ):
                raise ValidationError(_("Advance Payment already set"))
